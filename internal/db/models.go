// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Algorithm string

const (
	AlgorithmTOKENBUCKET   Algorithm = "TOKEN_BUCKET"
	AlgorithmFIXEDWINDOW   Algorithm = "FIXED_WINDOW"
	AlgorithmLEAKYBUCKET   Algorithm = "LEAKY_BUCKET"
	AlgorithmSLIDINGWINDOW Algorithm = "SLIDING_WINDOW"
)

func (e *Algorithm) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Algorithm(s)
	case string:
		*e = Algorithm(s)
	default:
		return fmt.Errorf("unsupported scan type for Algorithm: %T", src)
	}
	return nil
}

type NullAlgorithm struct {
	Algorithm Algorithm `json:"algorithm"`
	Valid     bool      `json:"valid"` // Valid is true if Algorithm is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAlgorithm) Scan(value interface{}) error {
	if value == nil {
		ns.Algorithm, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Algorithm.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAlgorithm) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Algorithm), nil
}

type Product string

const (
	ProductPRODUCT1 Product = "PRODUCT_1"
	ProductPRODUCT2 Product = "PRODUCT_2"
	ProductPRODUCT3 Product = "PRODUCT_3"
)

func (e *Product) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Product(s)
	case string:
		*e = Product(s)
	default:
		return fmt.Errorf("unsupported scan type for Product: %T", src)
	}
	return nil
}

type NullProduct struct {
	Product Product `json:"product"`
	Valid   bool    `json:"valid"` // Valid is true if Product is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProduct) Scan(value interface{}) error {
	if value == nil {
		ns.Product, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Product.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProduct) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Product), nil
}

type Status string

const (
	StatusACTIVE   Status = "ACTIVE"
	StatusINACTIVE Status = "INACTIVE"
)

func (e *Status) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Status(s)
	case string:
		*e = Status(s)
	default:
		return fmt.Errorf("unsupported scan type for Status: %T", src)
	}
	return nil
}

type NullStatus struct {
	Status Status `json:"status"`
	Valid  bool   `json:"valid"` // Valid is true if Status is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStatus) Scan(value interface{}) error {
	if value == nil {
		ns.Status, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Status.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Status), nil
}

type ApiKey struct {
	ID               int32            `db:"id" json:"id"`
	AccountID        uuid.UUID        `db:"account_id" json:"account_id"`
	Name             string           `db:"name" json:"name"`
	Description      *string          `db:"description" json:"description"`
	Key              uuid.UUID        `db:"key" json:"key"`
	Status           Status           `db:"status" json:"status"`
	CreatedBy        *string          `db:"created_by" json:"created_by"`
	LastUsed         pgtype.Timestamp `db:"last_used" json:"last_used"`
	RequestsConsumed *int64           `db:"requests_consumed" json:"requests_consumed"`
	Product          Product          `db:"product" json:"product"`
	PlanID           int32            `db:"plan_id" json:"plan_id"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type Plan struct {
	ID        int32            `db:"id" json:"id"`
	AccountID uuid.UUID        `db:"account_id" json:"account_id"`
	Name      string           `db:"name" json:"name"`
	RateLimit int32            `db:"rate_limit" json:"rate_limit"`
	BurstSize int32            `db:"burst_size" json:"burst_size"`
	Algorithm Algorithm        `db:"algorithm" json:"algorithm"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}
